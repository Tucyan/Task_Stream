# Task Stream 项目功能需求清单

## AI接入
 前端 手机AI设置内容隐藏到设置中而非在AI助手视图设置
 流式输出文本内容提升用户体验

 AI能做什么？
  工具助手agent：
    调用后端所有的接口，在删除时需要标红提示用户自行决定是否删除
    可能可以实现的功能列举：
      代替规划长期任务
      帮助用户新建任务
      提供任务建议
      提供规划建议
      调整任务的时间安排
      ......
      (工具层函数会赋予AI完整的增删改查能力)
  首页智能助手：
    提醒长期任务进度
    首页智能欢迎词
    一天快结束的时候智能夸夸等
    根据工具助手提供的提醒消息列表提醒用户



  
  AI设置：
    api-key：用户需要在AI设置中输入自己的api-key使用AI功能(否则用默认的)
    model：用户可以在AI设置中填写模型(否则用默认的)
    prompt：用户可以在AI设置中填写提示词(可选择是否生效，和预置提示词二选一)
    预置提示词：用户可以在AI设置中选择性格 温柔、正式、幽默、严厉 等不同的预置提示词（默认为温柔），选择的每个性格对应一套提示词（具体的提示词不展示出来写在后端python代码里）
    长期固定记忆：用户可以和agent共同决定长期固定记忆的内容，agent会根据用户的指令和长期固定记忆来更好的完成服务
    |is_enable_prompt|INTEGER|NOT NULL DEFAULT 0|是否启用prompt(0/1)|
|is_auto_confirm_create_request|INTEGER|NOT NULL DEFAULT 0|是否自动确认创建请求(0/1)|
|is_auto_confirm_update_request|INTEGER|NOT NULL DEFAULT 0|是否自动确认更改请求(0/1)|
|is_auto_confirm_delete_request|INTEGER|NOT NULL DEFAULT 0|是否自动确认删除请求(0/1)|
|is_auto_confirm_create_reminder|INTEGER|NOT NULL DEFAULT 0|是否自动确认新建提醒(0/1)|
  数据结构更改：
    长期任务表中新增更新时间字段，格式为yyyy-MM-dd HH:mm(默认为当前时间)
    长期任务表中新增上次提醒时间字段，格式为yyyy-MM-dd HH:mm(可以为空)

    定义AI总表：
|含义|字段名|类型|说明|
|---|---|---|---|
|主键|id|int|主键|
|用户id|user_id|int|用户id|
|api-key|api_key|varchar(255)|用户的api-key|
|模型|model|varchar(20)|用户选择的模型|
|提示词|prompt|varchar(255)|用户输入的提示词|
|性格|character|varchar(8)|用户选择的性格|
|长期固定记忆|long_term_memory|varchar(255)|用户输入的长期固定记忆|
|AI对话id列表|ai_dialogue_id_list|varchar(255)|用户与AI助手的对话id列表，逗号分隔记录AIAssistantMessage的主键(id)|
|是否启用prompt|is_enable_prompt|boolean|是否启用prompt|
|是否自动确认创建请求|is_auto_confirm_create_request|boolean|是否自动确认创建请求|
|是否自动确认更改请求|is_auto_confirm_update_request|boolean|是否自动确认更改请求| 
|是否自动确认删除请求|is_auto_confirm_delete_request|boolean|是否自动确认删除请求| 
|是否自动确认新建提醒|is_auto_confirm_create_reminder|boolean|是否自动确认新建提醒|
|提醒列表(根据提醒时间升序排序，在新建的时候维护提醒时间顺序)|reminder_list|varchar(255)|格式参考[{"type":"Message","time":"2023-08-01 12:00","content":"提醒内容"},{"type":"Task","time":"2023-08-01 18:00","content":"提醒内容","task_id":1},{"type":"LongTermTask","time":"2023-08-01 20:00","content":"提醒内容","task_id":1}]|

固定数据（写死在python代码里面的）：
|描述|变量名|类型|说明|
|---|---|---|---|
|默认性格|default_character|str|默认性格|
|主页agent提示词|home_agent_prompt|str|主页agent提示词|
|ai助手提示词|ai_assistant_prompt|str|告诉AI自己的角色以及能干什么(不包含性格的提示词)|
|默认的性格的提示词|default_character_prompt|列表包含字典|默认的性格的提示词，每个字典包含性格和对应的提示词|
|默认api-key|default_api_key|str|默认api-key，从.env文件中读取|
|默认模型|default_model|str|默认模型，从.env文件中读取|
|默认base_url|default_base_url|str|默认base_url，从.env文件中读取|
|上下文窗口大小|default_context_window_size|int|默认上下文窗口大小|

    备注：只支持openai格式的chatmodel
## 前端界面要求：
### AiAssistantView：
  这个页面直接全部删掉重做包括移动端和电脑端
  重做内容需要全部支持亮暗色主题以及强调色适配
  左侧有可折叠侧栏（默认折叠，移动到左侧边缘显示展开按钮样式为“>”的形状，展开之后变成“<”的形状，注意角度要稍大，不要和字符的开合角度一致或者直接使用字符作为交互按钮）显示对话标题，并有“新建对话”（置顶到所有的对话上面去）
  主区域是背景中直接显示对话内容，不再有内容区，直接把对话气泡显示在背景(暗色主题为深灰色背景，亮色主题为浅灰背景)中。
  手机中侧栏不可折叠和展开，独立成一个单独的区域，用户通过左右划切换侧栏和主区域（此时侧栏视作一个区域）
  不显示用户和AI助手的头像，只显示对话气泡，且对话气泡和左右边框的距离一致

  ### 已完成对话内容的前端渲染逻辑（基于 messages 字段）

  1. 前端从后端拉取某一会话的完整 `messages` 内容，并反序列化为 `ChatTurn[][]` 结构（详见《数据库定义文档》中 AIAssistantMessage 的定义）。
  2. 对于外层数组中的每一轮对话（一个 `ChatTurn[]`）：
     1. 依序遍历该轮中的所有 `ChatTurn`，按顺序渲染到界面：
        - 当 `role = "user"` 时：
          - 如果 `content` 为字符串：渲染为用户气泡，展示原始文本；
          - 若后续扩展允许用户侧也包含结构化内容，则同样按照 type 逻辑渲染（当前版本可忽略）。
        - 当 `role = "assistant"` 时：
          - 如果 `content` 为字符串：直接渲染为 AI 文本气泡（可用 markdown 渲染，比如 react-markdown）；
          - 如果 `content` 为数组：数组中的每一项视为一个“卡片或文本块”，逐个渲染：
            - `type = 0`：渲染普通文本气泡，使用 markdown 解析（支持加粗、列表等）；
            - `type = 1`：渲染“新建任务卡片”，展示标题、描述、执行时间、时间段、截止日期、分配日期、标签等信息，并根据 AI 设置决定是否展示“确定 / 取消”按钮；
            - `type = 2`：渲染“长期任务卡片”，展示长期任务标题、描述、截止时间与子任务列表（标题 + 权重）；
            - `type = 3`：渲染“任务 diff 卡片”，左右（或上下）展示 before / after 两张任务卡片，字段差异通过 markdown 粗体（`**内容**`）高亮显示，保留任务 id 以便后续操作；
            - `type = 4`：渲染“长期任务 diff 卡片”，同样左右（或上下）展示 before / after 两张长期任务卡片，字段差异用 markdown 粗体高亮，并保留长期任务 id；
            - `type = 5`：渲染“删除列表卡片”，展示若干待删除任务的标题列表，每一项包含 id 和 title，可点击查看详情并支持“取消删除”，已取消的项在列表中以删除线效果展示；
            - `type = 6`：渲染“提醒卡片”，展示提醒类型、时间、内容，以及可选的关联任务 id（例如点击可以跳转到对应任务）；
            - `type = 7`：作为预留扩展类型，根据 data 内容和后续协议定义进行渲染。
     2. 已完成的会话仅按上述结构“静态渲染”，不涉及任何流式动画逻辑。

  ### 流式渲染的状态机与五个角色的逻辑（LangChain Agent 版本）

  参与流式输出的 5 个角色：
  1. **前端渲染角色**：负责展示对话、驱动 UI 状态机、维护本地 `messages` 状态；
  2. **前端通信角色**：负责与后端建立 SSE 连接，接收流式事件（tokens / 结构化卡片），并处理用户确认/取消操作的请求发送；
  3. **后端中间层（Middleware / Output Manager）**：
     - **核心枢纽**：所有的 Agent 文本流和 Tool 卡片数据都必须经过它发送给前端；
     - **流式管理**：接收 Agent 的 token 并封装为 `partial_text` 事件推送；
     - **卡片管理**：接收 Tool 层生成的卡片 JSON，封装为 `cards` 事件推送；
     - **确认控制**：根据 `AIConfig` 的自动确认设置，决定是否挂起等待前端的确认请求（`confirm` / `cancel`），并将结果返回给 Tool 层。
  4. **LLM 工具调用层（Tool Layer）**：
     - **双向通信**：被 Agent 调用时，首先构造用于前端渲染的 **卡片 JSON 数据**，传递给 **中间层**；
     - **逻辑执行**：等待 **中间层** 返回的确认结果（自动确认或用户手动确认）：
       - 若确认：执行实际的 CRUD 业务逻辑（如写入数据库），并将“执行成功”的结果返回给 Agent；
       - 若取消：不执行业务逻辑，将“用户取消操作”的结果返回给 Agent。
  5. **Agent（LangChain 智能体）**：
     - **大脑**：负责规划任务、生成文本（流式传给中间层）和发起工具调用（Call Tools）；
     - **决策闭环**：根据 Tool 层返回的最终执行结果（成功或取消），决定下一步的回复或操作。

  #### 典型交互流程示例（新建任务）

  假设用户输入：“请帮我规划好明天早上8点背单词”

  1. **用户发送**：前端将消息发送给后端，建立流式连接。
  2. **Agent 思考**：Agent 开始运行，流式输出文本（如“好的，正在为您规划...”） -> **中间层** -> **前端**（文本流式显示）。
  3. **工具调用**：Agent 决定调用 `create_task` 工具，传入参数 `title="背单词", time="明天08:00"`。
  4. **工具层响应**：
     - `create_task` 工具函数被触发。
     - **生成卡片**：工具函数内部构造 `type=1`（新建任务）的 JSON 卡片数据。
     - **发送卡片**：工具函数调用 **中间层** 的 `send_card(json)` 方法。
     - **中间层处理**：
       - **中间层** 将卡片 JSON 推送给 **前端**（前端渲染卡片）。
       - **中间层** 检查用户设置 `is_auto_confirm_create_request`：
         - **情况 A（需要确认）**：中间层挂起，等待前端调用 `/confirm` 接口。
           - 用户在前端点击“确定” -> 前端调 API -> 中间层收到信号 -> 解除挂起，返回 `True` 给工具层。
         - **情况 B（自动确认）**：中间层不挂起，直接返回 `True` 给工具层。
  5. **执行业务**：
     - **工具层** 收到 `True` 后，调用 CRUD 函数真正将任务写入数据库。
     - **工具层** 返回字符串 `"任务已创建，ID为 101"` 给 **Agent**。
  6. **Agent 收尾**：Agent 收到工具执行结果，生成最终回复（如“任务已创建成功，记得按时完成哦”） -> **中间层** -> **前端**。



# 记录12.14的工作进度：
完成了ai助手的网页渲染以及后端逻辑设计以及初步的数据结构定义
初步完成了ai助手的前端界面设计[文字稿]

# 首页智能欢迎板块
## 数据库表单定义()
|说明|字段|类型|默认值|备注|
|--|--|--|--|--|
|user_id|user_id|int||用户id|
|首页智能欢迎词|home_welcome|string|""|用户登录后首页展示的欢迎词|
|上次更新的时间|last_update_time|int|0|上次更新提醒词的时间戳，用于判断是否需要更新|
|是否启用智能欢迎词|is_enable_intelligent_welcome|int|0|是否启用智能欢迎词(0/1)|

## 预期效果：
如果欢迎词为空，根据时间和今日任务完成状态展示固定欢迎词：
早上：{user_name}早上好！今天也要继续加油哦~
中午：{user_name}中午好！好好休息，继续努力哦~
下午+还有日程未完成：{user_name}下午好！今天还有{unfinished_schedule_count}项日程，继续加油哦！
下午+全部日程完成：{user_name}下午好！今天的日程已经完成了，真的超极棒的！
晚上+还有日程未完成：{user_name}晚上好！今天还有{unfinished_schedule_count}项日程，继续加油哦！
晚上+完成全部日程：今天的日程结束了，好好休息吧~

如果距离上次更新的时间 超过{update_interval}那么清空欢迎词，后端调用函数把{today_task_content}以及{home_intelligent_assistant_prompt}以及{current_time}重新生成简短的欢迎词。
如果未超过{minimum_update_interval}，在点击欢迎面板的时候后端调用函数把{today_task_content}以及{home_intelligent_assistant_prompt}和上一次的{home_welcome_content}和{current_time}给LLM随便说点什么然后返回前端输出(流式输出)

写死到python代码中的数据：
{update_interval}：3h
{minimum_update_interval}：12s
{home_intelligent_assistant_prompt}：


  


AI长期记忆相关：
限制上下文窗口大小，超过上下文窗口则对超过上下文窗口之前的内容记忆压缩，现有上下文窗口内的不需要压缩。长期记忆被压缩必然会导致信息缺失的问题，因此需要为AI新增一个工具，搜索本轮对话中历史内容，用于回答用户的问题。
  
# 下一阶段：
- 对安全方面进行一定的完善
- 日历
- 好友互动

- 日历
